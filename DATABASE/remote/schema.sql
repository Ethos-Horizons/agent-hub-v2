-- Generated by scripts/dump-db.mjs (lightweight schema export)

DO $$ BEGIN CREATE TYPE agent_kind AS ENUM( 'local', 'n8n'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;
DO $$ BEGIN CREATE TYPE agent_version_status AS ENUM( 'draft', 'active', 'deprecated'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;
DO $$ BEGIN CREATE TYPE auth_kind AS ENUM( 'apiKey', 'basic', 'oauth'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;
DO $$ BEGIN CREATE TYPE destination_kind AS ENUM( 'webhook', 'supabase-func', 'custom'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;
DO $$ BEGIN CREATE TYPE execution_status AS ENUM( 'queued', 'running', 'succeeded', 'failed'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS public.agent_bindings (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  agent_id uuid NOT NULL,
  n8n_base_url text NOT NULL,
  workflow_id varchar NOT NULL,
  auth_kind auth_kind NOT NULL,
  credentials_ref text,
  input_schema jsonb DEFAULT '{}'::jsonb,
  output_schema jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.agent_bindings ADD CONSTRAINT agent_bindings_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX agent_bindings_agent_id_workflow_id_key ON public.agent_bindings USING btree (agent_id, workflow_id);
CREATE UNIQUE INDEX agent_bindings_pkey ON public.agent_bindings USING btree (id);
CREATE INDEX idx_agent_bindings_agent_id ON public.agent_bindings USING btree (agent_id);
CREATE INDEX idx_agent_bindings_workflow_id ON public.agent_bindings USING btree (workflow_id);

ALTER TABLE public.agent_bindings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can delete their own agent bindings" ON public.agent_bindings FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_bindings.agent_id)))));
CREATE POLICY "Users can insert their own agent bindings" ON public.agent_bindings FOR ALL WITH CHECK ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_bindings.agent_id)))));
CREATE POLICY "Users can update their own agent bindings" ON public.agent_bindings FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_bindings.agent_id)))));
CREATE POLICY "Users can view their own agent bindings" ON public.agent_bindings FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_bindings.agent_id)))));

CREATE TABLE IF NOT EXISTS public.agent_executions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid,
  agent_id uuid NOT NULL,
  agent_version_id uuid,
  destination_id uuid,
  input jsonb DEFAULT '{}'::jsonb,
  output jsonb DEFAULT '{}'::jsonb,
  status execution_status DEFAULT 'queued'::execution_status,
  started_at timestamptz,
  finished_at timestamptz,
  error_text text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.agent_executions ADD CONSTRAINT agent_executions_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;
ALTER TABLE public.agent_executions ADD CONSTRAINT agent_executions_agent_version_id_fkey FOREIGN KEY (agent_version_id) REFERENCES agent_versions(id) ON DELETE SET NULL;
ALTER TABLE public.agent_executions ADD CONSTRAINT agent_executions_destination_id_fkey FOREIGN KEY (destination_id) REFERENCES destinations(id) ON DELETE SET NULL;

CREATE UNIQUE INDEX agent_executions_pkey ON public.agent_executions USING btree (id);
CREATE INDEX idx_agent_executions_agent_id ON public.agent_executions USING btree (agent_id);
CREATE INDEX idx_agent_executions_created_at ON public.agent_executions USING btree (created_at);
CREATE INDEX idx_agent_executions_status ON public.agent_executions USING btree (status);
CREATE INDEX idx_agent_executions_tenant_id ON public.agent_executions USING btree (tenant_id);

ALTER TABLE public.agent_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Service role can manage executions" ON public.agent_executions FOR ALL USING ((auth.role() = 'service_role'::text));
CREATE POLICY "Users can view their own executions" ON public.agent_executions FOR ALL USING ((tenant_id = auth.uid()));

CREATE TABLE IF NOT EXISTS public.agent_memories (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  agent_id uuid,
  content text NOT NULL,
  embedding vector,
  metadata jsonb DEFAULT '{}'::jsonb,
  importance_score float8 DEFAULT 0.5,
  memory_type varchar DEFAULT 'conversation'::character varying,
  created_at timestamptz DEFAULT now(),
  last_accessed timestamptz DEFAULT now(),
  access_count int4 DEFAULT 0,
  tenant_id uuid,
  PRIMARY KEY (id)
);

ALTER TABLE public.agent_memories ADD CONSTRAINT agent_memories_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;

CREATE INDEX agent_memories_agent_id_idx ON public.agent_memories USING btree (agent_id);
CREATE INDEX agent_memories_created_at_idx ON public.agent_memories USING btree (created_at);
CREATE INDEX agent_memories_embedding_idx ON public.agent_memories USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');
CREATE UNIQUE INDEX agent_memories_pkey ON public.agent_memories USING btree (id);

ALTER TABLE public.agent_memories ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.agent_memories FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's agent memories" ON public.agent_memories FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.agent_skills (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  agent_id uuid,
  skill_name varchar NOT NULL,
  skill_description text,
  examples jsonb DEFAULT '[]'::jsonb,
  embedding vector,
  usage_count int4 DEFAULT 0,
  success_rate float8 DEFAULT 0.0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  tenant_id uuid,
  PRIMARY KEY (id)
);

ALTER TABLE public.agent_skills ADD CONSTRAINT agent_skills_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;

CREATE INDEX agent_skills_agent_id_idx ON public.agent_skills USING btree (agent_id);
CREATE INDEX agent_skills_embedding_idx ON public.agent_skills USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');
CREATE UNIQUE INDEX agent_skills_pkey ON public.agent_skills USING btree (id);

ALTER TABLE public.agent_skills ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.agent_skills FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's agent skills" ON public.agent_skills FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.agent_versions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  agent_id uuid NOT NULL,
  version varchar NOT NULL,
  system_prompt text,
  default_params jsonb DEFAULT '{}'::jsonb,
  status agent_version_status DEFAULT 'draft'::agent_version_status,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.agent_versions ADD CONSTRAINT agent_versions_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX agent_versions_agent_id_version_key ON public.agent_versions USING btree (agent_id, version);
CREATE UNIQUE INDEX agent_versions_pkey ON public.agent_versions USING btree (id);
CREATE INDEX idx_agent_versions_agent_id ON public.agent_versions USING btree (agent_id);
CREATE INDEX idx_agent_versions_status ON public.agent_versions USING btree (status);

ALTER TABLE public.agent_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can delete their own agent versions" ON public.agent_versions FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_versions.agent_id)))));
CREATE POLICY "Users can insert their own agent versions" ON public.agent_versions FOR ALL WITH CHECK ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_versions.agent_id)))));
CREATE POLICY "Users can update their own agent versions" ON public.agent_versions FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_versions.agent_id)))));
CREATE POLICY "Users can view their own agent versions" ON public.agent_versions FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = auth.uid()) AND (user_agents.agent_id = agent_versions.agent_id)))));

CREATE TABLE IF NOT EXISTS public.agents (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  name varchar NOT NULL,
  type varchar NOT NULL,
  description text,
  status varchar DEFAULT 'inactive'::character varying,
  version varchar DEFAULT '1.0.0'::character varying,
  config jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  tenant_id uuid,
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX agents_pkey ON public.agents USING btree (id);

ALTER TABLE public.agents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins have full access to agents" ON public.agents FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = ( SELECT auth.uid() AS uid)) AND (user_roles.role = 'admin'::text)))));
CREATE POLICY "Allow all operations for authenticated users" ON public.agents FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's agents" ON public.agents FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));
CREATE POLICY "Users can delete their own agents" ON public.agents FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = ( SELECT auth.uid() AS uid)) AND (user_agents.agent_id = agents.id)))));
CREATE POLICY "Users can insert agents" ON public.agents FOR ALL WITH CHECK (true);
CREATE POLICY "Users can update their own agents" ON public.agents FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = ( SELECT auth.uid() AS uid)) AND (user_agents.agent_id = agents.id))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = ( SELECT auth.uid() AS uid)) AND (user_agents.agent_id = agents.id)))));
CREATE POLICY "Users can view their own agents" ON public.agents FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_agents
  WHERE ((user_agents.user_id = ( SELECT auth.uid() AS uid)) AND (user_agents.agent_id = agents.id)))));

CREATE TABLE IF NOT EXISTS public.api_keys (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  provider varchar NOT NULL,
  key_name varchar NOT NULL,
  encrypted_key text NOT NULL,
  is_active bool DEFAULT true,
  created_at timestamptz DEFAULT now(),
  tenant_id uuid,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX api_keys_pkey ON public.api_keys USING btree (id);

ALTER TABLE public.api_keys ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.api_keys FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's API keys" ON public.api_keys FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.artifacts (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  run_id uuid,
  kind text NOT NULL,
  title text,
  url text,
  content text,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.artifacts ADD CONSTRAINT artifacts_run_id_fkey FOREIGN KEY (run_id) REFERENCES runs(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX artifacts_pkey ON public.artifacts USING btree (id);

ALTER TABLE public.artifacts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can create artifacts for their runs" ON public.artifacts FOR ALL WITH CHECK ((EXISTS ( SELECT 1
   FROM ((runs r
     JOIN projects p ON ((r.project_id = p.id)))
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (r.id = artifacts.run_id)))));
CREATE POLICY "Users can view artifacts for their runs" ON public.artifacts FOR ALL USING ((EXISTS ( SELECT 1
   FROM ((runs r
     JOIN projects p ON ((r.project_id = p.id)))
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (r.id = artifacts.run_id)))));

CREATE TABLE IF NOT EXISTS public.conversation_context (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  conversation_id uuid,
  agent_id uuid,
  context_window text NOT NULL,
  embedding vector,
  turn_count int4 NOT NULL,
  created_at timestamptz DEFAULT now(),
  tenant_id uuid,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.conversation_context ADD CONSTRAINT conversation_context_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;
ALTER TABLE public.conversation_context ADD CONSTRAINT conversation_context_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE;

CREATE INDEX conversation_context_conversation_id_idx ON public.conversation_context USING btree (conversation_id);
CREATE INDEX conversation_context_embedding_idx ON public.conversation_context USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');
CREATE UNIQUE INDEX conversation_context_pkey ON public.conversation_context USING btree (id);

ALTER TABLE public.conversation_context ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.conversation_context FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's conversation contexts" ON public.conversation_context FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.conversations (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  visitor_id varchar NOT NULL,
  session_id uuid NOT NULL,
  start_time timestamptz DEFAULT now(),
  end_time timestamptz,
  status varchar DEFAULT 'active'::character varying,
  intent varchar,
  lead_qualified bool DEFAULT false,
  tenant_id uuid,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id);

ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.conversations FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's conversations" ON public.conversations FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.destinations (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid,
  name varchar NOT NULL,
  kind destination_kind NOT NULL,
  endpoint_url text NOT NULL,
  headers jsonb DEFAULT '{}'::jsonb,
  auth_config jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX destinations_pkey ON public.destinations USING btree (id);
CREATE INDEX idx_destinations_tenant_id ON public.destinations USING btree (tenant_id);

ALTER TABLE public.destinations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can delete their own destinations" ON public.destinations FOR ALL USING ((tenant_id = auth.uid()));
CREATE POLICY "Users can insert their own destinations" ON public.destinations FOR ALL WITH CHECK ((tenant_id = auth.uid()));
CREATE POLICY "Users can update their own destinations" ON public.destinations FOR ALL USING ((tenant_id = auth.uid()));
CREATE POLICY "Users can view their own destinations" ON public.destinations FOR ALL USING ((tenant_id = auth.uid()));

CREATE TABLE IF NOT EXISTS public.knowledge_base (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  agent_id uuid,
  title varchar NOT NULL,
  content text NOT NULL,
  embedding vector,
  source_type varchar DEFAULT 'document'::character varying,
  source_url text,
  metadata jsonb DEFAULT '{}'::jsonb,
  chunk_index int4 DEFAULT 0,
  parent_document_id uuid,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  tenant_id uuid,
  PRIMARY KEY (id)
);

ALTER TABLE public.knowledge_base ADD CONSTRAINT knowledge_base_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;

CREATE INDEX knowledge_base_agent_id_idx ON public.knowledge_base USING btree (agent_id);
CREATE INDEX knowledge_base_embedding_idx ON public.knowledge_base USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');
CREATE UNIQUE INDEX knowledge_base_pkey ON public.knowledge_base USING btree (id);

ALTER TABLE public.knowledge_base ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.knowledge_base FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's knowledge base" ON public.knowledge_base FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.leads (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  conversation_id uuid,
  visitor_info jsonb NOT NULL,
  qualification_data jsonb NOT NULL,
  status varchar DEFAULT 'new'::character varying,
  created_at timestamptz DEFAULT now(),
  tenant_id uuid,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.leads ADD CONSTRAINT leads_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES conversations(id);

CREATE UNIQUE INDEX leads_pkey ON public.leads USING btree (id);

ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.leads FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's leads" ON public.leads FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.memory (
  id int8 NOT NULL DEFAULT nextval('memory_id_seq'::regclass),
  project_id uuid,
  doc_id text,
  content text,
  embedding vector,
  PRIMARY KEY (id)
);

ALTER TABLE public.memory ADD CONSTRAINT memory_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE;

CREATE INDEX idx_memory_project_id ON public.memory USING btree (project_id);
CREATE INDEX memory_embedding_idx ON public.memory USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');
CREATE UNIQUE INDEX memory_pkey ON public.memory USING btree (id);

ALTER TABLE public.memory ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can access their project's memory" ON public.memory FOR ALL USING ((project_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));
CREATE POLICY "Users can create memory for their projects" ON public.memory FOR ALL WITH CHECK ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = memory.project_id)))));
CREATE POLICY "Users can view memory for their projects" ON public.memory FOR ALL USING ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = memory.project_id)))));

CREATE TABLE IF NOT EXISTS public.messages (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  conversation_id uuid,
  message_type varchar NOT NULL,
  content text NOT NULL,
  timestamp timestamptz DEFAULT now(),
  metadata jsonb DEFAULT '{}'::jsonb,
  tenant_id uuid,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.messages ADD CONSTRAINT messages_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.messages FOR ALL USING (true);
CREATE POLICY "Users can access their tenant's messages" ON public.messages FOR ALL USING ((tenant_id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.org_members (
  org_id uuid NOT NULL,
  user_id uuid NOT NULL,
  role text NOT NULL DEFAULT 'member'::text,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (org_id, user_id)
);

ALTER TABLE public.org_members ADD CONSTRAINT org_members_org_id_fkey FOREIGN KEY (org_id) REFERENCES orgs(id) ON DELETE CASCADE;
ALTER TABLE public.org_members ADD CONSTRAINT org_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX idx_org_members_user_id ON public.org_members USING btree (user_id);
CREATE UNIQUE INDEX org_members_pkey ON public.org_members USING btree (org_id, user_id);

ALTER TABLE public.org_members ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins have full access to org_members" ON public.org_members FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = ( SELECT auth.uid() AS uid)) AND (user_roles.role = 'admin'::text)))));
CREATE POLICY "Org owners can manage members" ON public.org_members FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members org_members_1
  WHERE ((org_members_1.user_id = ( SELECT auth.uid() AS uid)) AND (org_members_1.org_id = org_members_1.org_id) AND (org_members_1.role = 'owner'::text)))));
CREATE POLICY "Users can view members in their organizations" ON public.org_members FOR ALL USING ((org_id IN ( SELECT org_members_1.org_id
   FROM org_members org_members_1
  WHERE (org_members_1.user_id = auth_user_id()))));
CREATE POLICY "Users can view members of their orgs" ON public.org_members FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members om
  WHERE ((om.org_id = org_members.org_id) AND (om.user_id = ( SELECT auth.uid() AS uid))))));
CREATE POLICY "Users can view their org memberships" ON public.org_members FOR ALL USING ((user_id = ( SELECT auth.uid() AS uid)));

CREATE TABLE IF NOT EXISTS public.organizations (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  slug text NOT NULL,
  logo_url text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX organizations_pkey ON public.organizations USING btree (id);
CREATE UNIQUE INDEX organizations_slug_key ON public.organizations USING btree (slug);

ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their organizations" ON public.organizations FOR ALL USING ((id IN ( SELECT org_members.org_id
   FROM org_members
  WHERE (org_members.user_id = auth_user_id()))));

CREATE TABLE IF NOT EXISTS public.orgs (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  created_at timestamptz DEFAULT now(),
  slug text,
  settings jsonb DEFAULT '{}'::jsonb,
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX orgs_pkey ON public.orgs USING btree (id);
CREATE UNIQUE INDEX orgs_slug_key ON public.orgs USING btree (slug);

ALTER TABLE public.orgs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins have full access to orgs" ON public.orgs FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = ( SELECT auth.uid() AS uid)) AND (user_roles.role = 'admin'::text)))));
CREATE POLICY "Owners can delete orgs" ON public.orgs FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = orgs.id) AND (org_members.role = 'owner'::text)))));
CREATE POLICY "Owners can update orgs" ON public.orgs FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = orgs.id) AND (org_members.role = 'owner'::text))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = orgs.id) AND (org_members.role = 'owner'::text)))));
CREATE POLICY "Users can create orgs" ON public.orgs FOR ALL WITH CHECK (true);
CREATE POLICY "Users can view their orgs" ON public.orgs FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = orgs.id)))));

CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL,
  full_name text,
  avatar_url text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.profiles ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can update their own profile" ON public.profiles FOR ALL USING ((id = auth_user_id())) WITH CHECK ((id = auth_user_id()));
CREATE POLICY "Users can view profiles" ON public.profiles FOR ALL USING (true);

CREATE TABLE IF NOT EXISTS public.projects (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  org_id uuid,
  name text NOT NULL,
  plan text DEFAULT 'presence'::text,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.projects ADD CONSTRAINT projects_org_id_fkey FOREIGN KEY (org_id) REFERENCES orgs(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Org owners can manage projects" ON public.projects FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = projects.org_id) AND (org_members.role = 'owner'::text)))));
CREATE POLICY "Users can view projects in their orgs" ON public.projects FOR ALL USING ((EXISTS ( SELECT 1
   FROM org_members
  WHERE ((org_members.user_id = ( SELECT auth.uid() AS uid)) AND (org_members.org_id = projects.org_id)))));

CREATE TABLE IF NOT EXISTS public.runs (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  project_id uuid,
  agent text NOT NULL,
  status text NOT NULL DEFAULT 'queued'::text,
  input jsonb NOT NULL,
  output jsonb,
  cost_usd numeric DEFAULT 0,
  latency_ms int4 DEFAULT 0,
  n8n_execution_id text,
  error text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

ALTER TABLE public.runs ADD CONSTRAINT runs_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE;

CREATE INDEX idx_runs_project_id ON public.runs USING btree (project_id);
CREATE INDEX idx_runs_status ON public.runs USING btree (status);
CREATE UNIQUE INDEX runs_pkey ON public.runs USING btree (id);

ALTER TABLE public.runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can create runs in their projects" ON public.runs FOR ALL WITH CHECK ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = runs.project_id)))));
CREATE POLICY "Users can update runs in their projects" ON public.runs FOR ALL USING ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = runs.project_id))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = runs.project_id)))));
CREATE POLICY "Users can view runs in their projects" ON public.runs FOR ALL USING ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN org_members om ON ((p.org_id = om.org_id)))
  WHERE ((om.user_id = ( SELECT auth.uid() AS uid)) AND (p.id = runs.project_id)))));

CREATE TABLE IF NOT EXISTS public.system_settings (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  setting_key varchar NOT NULL,
  setting_value jsonb NOT NULL,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
);

CREATE UNIQUE INDEX system_settings_pkey ON public.system_settings USING btree (id);
CREATE UNIQUE INDEX system_settings_setting_key_key ON public.system_settings USING btree (setting_key);

ALTER TABLE public.system_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations for authenticated users" ON public.system_settings FOR ALL USING (true);

CREATE TABLE IF NOT EXISTS public.user_agents (
  user_id uuid NOT NULL,
  agent_id uuid NOT NULL,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (user_id, agent_id)
);

ALTER TABLE public.user_agents ADD CONSTRAINT user_agents_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE;
ALTER TABLE public.user_agents ADD CONSTRAINT user_agents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE UNIQUE INDEX user_agents_pkey ON public.user_agents USING btree (user_id, agent_id);

ALTER TABLE public.user_agents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins have full access to user_agents" ON public.user_agents FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = ( SELECT auth.uid() AS uid)) AND (user_roles.role = 'admin'::text)))));
CREATE POLICY "Users can view their own agent associations" ON public.user_agents FOR ALL USING ((user_id = ( SELECT auth.uid() AS uid)));

CREATE TABLE IF NOT EXISTS public.user_roles (
  user_id uuid NOT NULL,
  role text NOT NULL,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (user_id, role)
);

ALTER TABLE public.user_roles ADD CONSTRAINT user_roles_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX idx_user_roles_user_id ON public.user_roles USING btree (user_id);
CREATE UNIQUE INDEX user_roles_pkey ON public.user_roles USING btree (user_id, role);

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins have full access to user_roles" ON public.user_roles FOR ALL USING ((EXISTS ( SELECT 1
   FROM user_roles user_roles_1
  WHERE ((user_roles_1.user_id = ( SELECT auth.uid() AS uid)) AND (user_roles_1.role = 'admin'::text)))));
CREATE POLICY "Users can view their own roles" ON public.user_roles FOR ALL USING ((user_id = ( SELECT auth.uid() AS uid)));
